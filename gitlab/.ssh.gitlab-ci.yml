stages:
  - build
  - deploy

# VPN via Gluetun
.use_vpn_service:
  services:
    - name: qmcgaw/gluetun
      alias: gluetun
      # Override entrypoint to first write the config file
      entrypoint: [ "/bin/sh", "-c" ]
      command:
        - |
          echo "Creating OpenVPN config file...";
          if [ "$VPN_TYPE" = "openvpn" ]; then
            echo "Writing OpenVPN configuration to /gluetun/custom.conf";
            mkdir -p /gluetun && echo "$OPENVPN_CONFIG_CONTENT" > /gluetun/custom.conf
          elif [ "$VPN_TYPE" = "wireguard" ]; then
            echo "Writing WireGuard configuration to /gluetun/wireguard/wg0.conf";
            # Ensure the directory exists and write the WireGuard config
            mkdir -p /gluetun/wireguard && echo "$WIREGUARD_CONFIG_CONTENT" > /gluetun/wireguard/wg0.conf
          fi
          # Execute the original entrypoint
          echo "Starting Gluetun with VPN configuration...";
          exec /gluetun-entrypoint "$@"
  variables:
    HTTPPROXY: "on"
    VPN_SERVICE_PROVIDER: custom
    VPN_TYPE: $VPN_TYPE # Either "wireguard" or "openvpn"
    # WireGuard specific variables
    WIREGUARD_CONFIG_CONTENT: $WIREGUARD_CONFIG_CONTENT # Full WireGuard config content
    # OpenVPN specific variables
    OPENVPN_USER: $OPENVPN_USER # For username/password auth. Not needed for cert auth.
    OPENVPN_PASSWORD: $OPENVPN_PASSWORD # For username/password auth. Not needed for cert auth.
    OPENVPN_CONFIG_CONTENT: $OPENVPN_CONFIG_CONTENT # Full OpenVPN config content
    OPENVPN_CUSTOM_CONFIG: /gluetun/custom.conf # Path to the custom OpenVPN config file that will be written
  before_script: &vpn_health_check
    # Install curl and check VPN health before proceeding
    - apk add --no-cache curl
    - echo "Waiting for VPN service to report a healthy connection..."
    - |
      for i in $(seq 1 3); do
        echo "Attempt $i: Checking connectivity to http://$DEPLOY_HOST:$DEPLOY_PORT  ..."
        curl -s -o /dev/null --connect-timeout 5 --proxy http://gluetun:8888 http://$DEPLOY_HOST:$DEPLOY_PORT
        CURL_EXIT_CODE=$?

        # Check for successful exit codes: 0 (OK) or 56 (Reset by peer caused by CURLing an SSH port instead of HTTP)
        if [ $CURL_EXIT_CODE -eq 0 ] || [ $CURL_EXIT_CODE -eq 56 ]; then
          echo "VPN proxy is active and SSH port is reachable (Exit Code: $CURL_EXIT_CODE)."
          VPN_OK=1
          break
        fi

        echo "Host $DEPLOY_HOST:$DEPLOY_PORT not yet reachable (Exit Code: $CURL_EXIT_CODE). Waiting 5 seconds..."
        sleep 5
      done

      if [ -z "$VPN_OK" ]; then
        # If VPN_OK is not set, it means the connection was not successful
        echo "ERROR: VPN service did not connect in time, $DEPLOY_HOST:$DEPLOY_PORT was not reachable through the VPN."
        exit 1
      else
        echo "VPN service is healthy and $DEPLOY_HOST:$DEPLOY_PORT is reachable through the VPN."
      fi

.build frontend base:
  image: node:22
  stage: build
  artifacts:
    expire_in: 1 week
    paths:
      - dist
  cache:
    - paths:
        - node_modules
  script:
    - npm config set @kibro:registry https://gitlab.kiwis-and-brownies.de/api/v4/packages/npm/
    - 'echo "//gitlab.kiwis-and-brownies.de/api/v4/packages/npm/:_authToken=${CI_JOB_TOKEN}" >> ~/.npmrc'
    - 'echo "//gitlab.kiwis-and-brownies.de/api/v4/projects/15/packages/npm/:_authToken=${CI_JOB_TOKEN}" >> ~/.npmrc'
    - 'echo "//gitlab.kiwis-and-brownies.de/api/v4/projects/18/packages/npm/:_authToken=${CI_JOB_TOKEN}" >> ~/.npmrc'
    - 'echo "//gitlab.kiwis-and-brownies.de/api/v4/projects/19/packages/npm/:_authToken=${CI_JOB_TOKEN}" >> ~/.npmrc'
    - 'echo "//gitlab.kiwis-and-brownies.de/api/v4/projects/44/packages/npm/:_authToken=${CI_JOB_TOKEN}" >> ~/.npmrc'
    - 'echo "//gitlab.kiwis-and-brownies.de/api/v4/projects/58/packages/npm/:_authToken=${CI_JOB_TOKEN}" >> ~/.npmrc'
    - npm ci
    - npm run build

.deploy frontend base:
  image: alpine
  stage: deploy
  before_script: &deploy_frontend_base_before_script
    # Add dependencies
    - apk add --no-cache rsync openssh
    # ssh connect
    - mkdir -p ~/.ssh
    - eval $(ssh-agent -s)
    - echo -e "Host *\n\tStrictHostKeyChecking no\n\n" > ~/.ssh/config
    - ssh-add <(echo "$PRIVATE_KEY")
  script:
    # This syncs only the dist directory
    - rsync -e "ssh -p $DEPLOY_PORT" -rav --delete dist $DEPLOY_USER@$DEPLOY_HOST:$DEPLOY_PATH

.deploy backend base:
  image: alpine
  stage: deploy
  before_script: &deploy_backend_base_before_script
    # Add dependencies
    - apk add --no-cache openssh
    # ssh connect
    - mkdir -p ~/.ssh
    - eval $(ssh-agent -s)
    - echo -e "Host *\n\tStrictHostKeyChecking no\n\n" > ~/.ssh/config
    - ssh-add <(echo "$PRIVATE_KEY")
  script:
    - ssh -tt -p $DEPLOY_PORT $DEPLOY_USER@$DEPLOY_HOST "cd $DEPLOY_PATH && (git clone --recurse-submodules git@$CI_SERVER_HOST:$CI_PROJECT_PATH.git . || (git reset --hard HEAD && git pull --recurse-submodules))"
    - ssh -tt -p $DEPLOY_PORT $DEPLOY_USER@$DEPLOY_HOST "cd $DEPLOY_PATH && composer config --auth gitlab-token.gitlab.kiwis-and-brownies.de $PACKAGE_TOKEN_USER "$PACKAGE_TOKEN" --no-ansi --no-interaction"
    - ssh -tt -p $DEPLOY_PORT $DEPLOY_USER@$DEPLOY_HOST "cd $DEPLOY_PATH && composer install --no-interaction --no-dev"
    - ssh -tt -p $DEPLOY_PORT $DEPLOY_USER@$DEPLOY_HOST "cd $DEPLOY_PATH && php bakery init --force"
    - ssh -tt -p $DEPLOY_PORT $DEPLOY_USER@$DEPLOY_HOST "cd $DEPLOY_PATH && php bakery migrate --force"
    - ssh -tt -p $DEPLOY_PORT $DEPLOY_USER@$DEPLOY_HOST "cd $DEPLOY_PATH && php bakery apply"
    - ssh -tt -p $DEPLOY_PORT $DEPLOY_USER@$DEPLOY_HOST "cd $DEPLOY_PATH && php bakery load --force"
    - ssh -tt -p $DEPLOY_PORT $DEPLOY_USER@$DEPLOY_HOST "cd $DEPLOY_PATH && php bakery make:supervisor"
    - ssh -tt -p $DEPLOY_PORT $DEPLOY_USER@$DEPLOY_HOST "cd $DEPLOY_PATH && (supervisorctl update all || true)"

build frontend:
  extends: .build frontend base
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'

deploy frontend:
  extends: .deploy frontend base
  needs:
    - build frontend
  rules:
    # Run this job on the 'main' branch ONLY IF $USE_VPN is not "true"
    - if: '$CI_COMMIT_BRANCH == "main" && $USE_VPN != "true"'
  variables:
    DEPLOY_HOST: $PROD_HOST
    DEPLOY_PORT: $PROD_PORT
    DEPLOY_USER: $PROD_USER
    DEPLOY_PATH: $PROD_PATH

deploy frontend with vpn:
  extends:
    - deploy frontend      # Inherits needs, variables, etc.
    - .use_vpn_service     # Adds the VPN service and scripts
  rules:
    # Run this job on the 'main' branch ONLY IF $USE_VPN is not "true"
    - if: '$CI_COMMIT_BRANCH == "main" && $USE_VPN == "true"'
  # Since we can only have one VPN connection active at a time, we need to execute the deployment jobs sequentially.
  #  needs:
  #    - deploy backend with vpn
  before_script:
    - *vpn_health_check
    - *deploy_frontend_base_before_script
    # Now, we "extend" the before_script to include corkscrew for SSH tunneling
    - apk add --no-cache corkscrew
    - sed -i '/^Host \*/a\ ProxyCommand corkscrew gluetun 8888 %h %p' ~/.ssh/config


deploy backend:
  extends: .deploy backend base
  rules:
    # Run this job on the 'main' branch ONLY IF $USE_VPN is not "true"
    - if: '$CI_COMMIT_BRANCH == "main" && $USE_VPN != "true"'
  variables:
    DEPLOY_HOST: $PROD_HOST
    DEPLOY_PORT: $PROD_PORT
    DEPLOY_USER: $PROD_USER
    DEPLOY_PATH: $PROD_PATH

deploy backend with vpn:
  extends:
    - deploy backend
    - .use_vpn_service
  rules:
    - if: '$CI_COMMIT_BRANCH == "main" && $USE_VPN == "true"'
  before_script:
    - *vpn_health_check
    - *deploy_backend_base_before_script
    # Now, we "extend" the before_script to include corkscrew for SSH tunneling
    - apk add --no-cache corkscrew
    - sed -i '/^Host \*/a\ ProxyCommand corkscrew gluetun 8888 %h %p' ~/.ssh/config

deploy backend staging:
  extends: .deploy backend base
  rules:
    - if: '$CI_COMMIT_BRANCH == "staging" && $USE_VPN != "true"'
  variables:
    DEPLOY_HOST: $STAGING_HOST
    DEPLOY_PORT: $STAGING_PORT
    DEPLOY_USER: $STAGING_USER
    DEPLOY_PATH: $STAGING_PATH

deploy backend staging with vpn:
  extends:
    - deploy backend staging
    - .use_vpn_service
  rules:
    - if: '$CI_COMMIT_BRANCH == "staging" && $USE_VPN == "true"'
  before_script:
    - *vpn_health_check
    - *deploy_backend_base_before_script
    # Now, we "extend" the before_script to include corkscrew for SSH tunneling
    - apk add --no-cache corkscrew
    - sed -i '/^Host \*/a\ ProxyCommand corkscrew gluetun 8888 %h %p' ~/.ssh/config

build frontend staging:
  extends: .build frontend base
  rules:
    - if: '$CI_COMMIT_BRANCH == "staging"'
  variables:
    VUE_APP_API_URL: $STAGING_API_URL
    VUE_APP_SYSTEM: $STAGING_SYSTEM

deploy frontend staging:
  extends: .deploy frontend base
  rules:
    - if: '$CI_COMMIT_BRANCH == "staging" && $USE_VPN != "true"'
  needs:
    - build frontend staging
  variables:
    DEPLOY_HOST: $STAGING_HOST
    DEPLOY_PORT: $STAGING_PORT
    DEPLOY_USER: $STAGING_USER
    DEPLOY_PATH: $STAGING_PATH

deploy frontend staging with vpn:
  extends:
    - deploy frontend staging
    - .use_vpn_service
  rules:
    - if: '$CI_COMMIT_BRANCH == "staging" && $USE_VPN == "true"'
  # Since we can only have one VPN connection active at a time, we need to execute the deployment jobs sequentially.
  needs:
    - deploy backend staging with vpn
  before_script:
    - *vpn_health_check
    - *deploy_frontend_base_before_script
    # Now, we "extend" the before_script to include corkscrew for SSH tunneling
    - apk add --no-cache corkscrew
    - sed -i '/^Host \*/a\ ProxyCommand corkscrew gluetun 8888 %h %p' ~/.ssh/config
