stages:
  - build
  - deploy

.ssh_configuration:
  before_script: &ssh_configuration
    - apk add --no-cache openssh-client
    - mkdir -p ~/.ssh
    - eval $(ssh-agent -s)
    - echo -e "Host *\n  StrictHostKeyChecking no\n" > ~/.ssh/config
    - ssh-add <(echo "$PRIVATE_KEY")

# VPN via Gluetun
.use_vpn_service:
  services:
    - name: qmcgaw/gluetun
      alias: gluetun
      # Override entrypoint to first write the config file
      entrypoint: [ "/bin/sh", "-c" ]
      command:
        - |
          echo "Creating OpenVPN config file...";
          if [ "$VPN_TYPE" = "openvpn" ]; then
            echo "Writing OpenVPN configuration to /gluetun/custom.conf";
            mkdir -p /gluetun && echo "$OPENVPN_CONFIG_CONTENT" > /gluetun/custom.conf
          elif [ "$VPN_TYPE" = "wireguard" ]; then
            echo "Writing WireGuard configuration to /gluetun/wireguard/wg0.conf";
            # Ensure the directory exists and write the WireGuard config
            mkdir -p /gluetun/wireguard && echo "$WIREGUARD_CONFIG_CONTENT" > /gluetun/wireguard/wg0.conf
          fi
          # Execute the original entrypoint
          echo "Starting Gluetun with VPN configuration...";
          exec /gluetun-entrypoint "$@"
  variables:
    SHADOWSOCKS: "on" # Enable Shadowsocks for SOCKS5 proxy support
    SHADOWSOCKS_PORT: "8338" # Port for the Shadowsocks proxy
    SHADOWSOCKS_PASSWORD: "super_secret_password"
    VPN_SERVICE_PROVIDER: custom # Use "custom" to provide your own config
    VPN_TYPE: $VPN_TYPE # Either "wireguard" or "openvpn"
    # WireGuard specific variables
    WIREGUARD_CONFIG_CONTENT: $WIREGUARD_CONFIG_CONTENT # Full WireGuard config content
    # OpenVPN specific variables
    OPENVPN_USER: $OPENVPN_USER # For username/password auth. Not needed for cert auth.
    OPENVPN_PASSWORD: $OPENVPN_PASSWORD # For username/password auth. Not needed for cert auth.
    OPENVPN_CONFIG_CONTENT: $OPENVPN_CONFIG_CONTENT # Full OpenVPN config content
    OPENVPN_CUSTOM_CONFIG: /gluetun/custom.conf # Path to the custom OpenVPN config file that will be written
  before_script: &vpn_setup
    # Install helper for SSH over SOCKS5 (aka. Shadowsocks)
    - apk add --no-cache curl shadowsocks-rust-sslocal netcat-openbsd
    - echo "Waiting for VPN service to report a healthy connection..."
    - |
      echo "Waiting for Gluetun health check endpoint to be available..."
      GLUETUN_OK=""
      for i in $(seq 1 10); do
        echo "Attempt $i: Checking Gluetun health endpoint..."
        if curl -s -o /dev/null http://gluetun:8000/v1/health; then
          echo "Gluetun is now healthy."
          GLUETUN_OK=1
          break
        fi
        echo "Gluetun not yet healthy. Waiting 5 seconds..."
        sleep 5
      done

      if [ -z "$GLUETUN_OK" ]; then
        echo "ERROR: Gluetun health check timed out after 10 attempts."
        exit 1
      fi

      echo "Starting Shadowsocks client to provide SSH-compatible SOCKS5 proxy..."
      # That will start a SOCKS5 proxy at 127.0.0.1:1080, forwarding to the Gluetun Shadowsocks server on port 8338
      sslocal --server-addr gluetun:8338 --local-addr 127.0.0.1:1080 --encrypt-method chacha20-ietf-poly1305 --password super_secret_password &
      SSLOCAL_PID=$!
      sleep 2
      if ! kill -0 $SSLOCAL_PID 2>/dev/null; then
        echo "Shadowsocks proxy via sslocal failed to start"
        exit 1
      fi
      echo "Shadowsocks client is running (PID $SSLOCAL_PID)"

      echo "Adding .ssh/config entries to use VPN for SSH connections..."
      echo '  ProxyCommand nc -X 5 -x 127.0.0.1:1080 %h %p' >> ~/.ssh/config
      echo '  ServerAliveInterval 30' >> ~/.ssh/config
      echo '  ServerAliveCountMax 5' >> ~/.ssh/config
      echo '  ConnectTimeout 10' >> ~/.ssh/config

      echo "Performing end-to-end SSH health check..."
      SSH_OK=""
      for i in $(seq 1 5); do
        echo "Attempt $i: Connecting to $DEPLOY_HOST:$DEPLOY_PORT..."
        if ssh -p $DEPLOY_PORT $DEPLOY_USER@$DEPLOY_HOST "echo 'Hello from CI/CD connection attempt' > /dev/null"; then
          echo "SSH connection successful."
          SSH_OK=1
          break
        fi
        echo "SSH connection failed. Retrying in 5 seconds..."
        sleep 5
      done

      if [ -z "$SSH_OK" ]; then
        echo "ERROR: SSH health check failed. Could not connect to remote host."
        exit 1
      fi

      echo "SSH tunnel is healthy and ready for deployment."

.build frontend base:
  image: node:22
  stage: build
  artifacts:
    expire_in: 1 week
    paths:
      - dist
  cache:
    - paths:
        - node_modules
  script:
    - npm config set @kibro:registry https://gitlab.kiwis-and-brownies.de/api/v4/packages/npm/
    - 'echo "//gitlab.kiwis-and-brownies.de/api/v4/packages/npm/:_authToken=${CI_JOB_TOKEN}" >> ~/.npmrc'
    - 'echo "//gitlab.kiwis-and-brownies.de/api/v4/projects/15/packages/npm/:_authToken=${CI_JOB_TOKEN}" >> ~/.npmrc'
    - 'echo "//gitlab.kiwis-and-brownies.de/api/v4/projects/18/packages/npm/:_authToken=${CI_JOB_TOKEN}" >> ~/.npmrc'
    - 'echo "//gitlab.kiwis-and-brownies.de/api/v4/projects/19/packages/npm/:_authToken=${CI_JOB_TOKEN}" >> ~/.npmrc'
    - 'echo "//gitlab.kiwis-and-brownies.de/api/v4/projects/44/packages/npm/:_authToken=${CI_JOB_TOKEN}" >> ~/.npmrc'
    - 'echo "//gitlab.kiwis-and-brownies.de/api/v4/projects/58/packages/npm/:_authToken=${CI_JOB_TOKEN}" >> ~/.npmrc'
    - npm ci
    - npm run build

.deploy frontend base:
  image: alpine
  stage: deploy
  before_script: &deploy_frontend_base_before_script
    - apk add --no-cache rsync # rsync is needed for the deployment of the frontend
    - *ssh_configuration
  script:
    # This syncs only the dist directory
    - rsync -e "ssh -F $HOME/.ssh/config -p $DEPLOY_PORT" -rav --delete dist $DEPLOY_USER@$DEPLOY_HOST:$DEPLOY_PATH

.deploy backend base:
  image: alpine
  stage: deploy
  before_script:
    - *ssh_configuration
  script:
    - |
      ssh -p $DEPLOY_PORT $DEPLOY_USER@$DEPLOY_HOST /bin/bash << EOL
        # This command sends the entire script block to the remote server to be executed in a single session.
        # 'set -e' ensures that the script will exit immediately if any command fails.
        set -e

        echo "--- Navigating to deployment directory ---"
        cd "$DEPLOY_PATH"

        echo "--- Updating source code from Git repository ---"
        # This logic handles both the first-time clone and subsequent updates.
        if [ -d ".git" ]; then
          echo "Repository exists. Resetting and pulling latest changes."
          git reset --hard HEAD
          git pull --recurse-submodules
        else
          echo "Cloning new repository."
          git clone --recurse-submodules --branch "$CI_COMMIT_BRANCH" "git@${CI_SERVER_HOST}:${CI_PROJECT_PATH}.git" .
        fi

        echo "--- Configuring Composer authentication ---"
        composer config --auth "gitlab-token.gitlab.kiwis-and-brownies.de" "${PACKAGE_TOKEN_USER}" "${PACKAGE_TOKEN}" --no-ansi --no-interaction

        echo "--- Installing Composer dependencies ---"
        composer install --no-interaction --no-dev --optimize-autoloader

        echo "--- Running application setup (Bakery) ---"
        php bakery init --force
        php bakery migrate --force
        php bakery apply
        php bakery load --force
        php bakery queue:restart
        php bakery make:supervisor

        echo "-- Updating Supervisor configuration ---"
        # '|| true' prevents the job from failing if supervisor has no changes to apply
        supervisorctl update all || true

        echo "Deployment finished successfully!"
      EOL

build frontend:
  extends: .build frontend base
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'

deploy frontend:
  extends: .deploy frontend base
  needs:
    - build frontend
  rules:
    # Run this job on the 'main' branch ONLY IF $USE_VPN is not "true"
    - if: '$CI_COMMIT_BRANCH == "main" && $USE_VPN != "true"'
  variables:
    DEPLOY_HOST: $PROD_HOST
    DEPLOY_PORT: $PROD_PORT
    DEPLOY_USER: $PROD_USER
    DEPLOY_PATH: $PROD_PATH

deploy frontend with vpn:
  extends:
    - deploy frontend      # Inherits needs, variables, etc.
    - .use_vpn_service     # Adds the VPN service and scripts
  rules:
    # Run this job on the 'main' branch ONLY IF $USE_VPN is not "true"
    - if: '$CI_COMMIT_BRANCH == "main" && $USE_VPN == "true"'
  retry: 2 # Retries this job up to 2 times upon failure. VPN's can be flaky, so this is useful.
  # Since we can only have one VPN connection active at a time, we need to execute the deployment jobs sequentially.
  needs:
    - job: build frontend          # 1. Download artifacts from the build job
    - job: deploy backend with vpn # 2. Wait for the backend deploy to finish successfully
  before_script:
    - *ssh_configuration
    - *deploy_frontend_base_before_script
    - *vpn_setup


deploy backend:
  extends: .deploy backend base
  rules:
    # Run this job on the 'main' branch ONLY IF $USE_VPN is not "true"
    - if: '$CI_COMMIT_BRANCH == "main" && $USE_VPN != "true"'
  variables:
    DEPLOY_HOST: $PROD_HOST
    DEPLOY_PORT: $PROD_PORT
    DEPLOY_USER: $PROD_USER
    DEPLOY_PATH: $PROD_PATH

deploy backend with vpn:
  extends:
    - deploy backend
    - .use_vpn_service
  rules:
    - if: '$CI_COMMIT_BRANCH == "main" && $USE_VPN == "true"'
  retry: 2 # Retries this job up to 2 times upon failure. VPN's can be flaky, so this is useful.
  before_script:
    - *ssh_configuration
    - *vpn_setup

deploy backend staging:
  extends: .deploy backend base
  rules:
    - if: '$CI_COMMIT_BRANCH == "staging" && $USE_VPN != "true"'
  variables:
    DEPLOY_HOST: $STAGING_HOST
    DEPLOY_PORT: $STAGING_PORT
    DEPLOY_USER: $STAGING_USER
    DEPLOY_PATH: $STAGING_PATH

deploy backend staging with vpn:
  extends:
    - deploy backend staging
    - .use_vpn_service
  rules:
    - if: '$CI_COMMIT_BRANCH == "staging" && $USE_VPN == "true"'
  retry: 2 # Retries this job up to 2 times upon failure. VPN's can be flaky, so this is useful.
  before_script:
    - *ssh_configuration
    - *vpn_setup

build frontend staging:
  extends: .build frontend base
  rules:
    - if: '$CI_COMMIT_BRANCH == "staging"'
  variables:
    VUE_APP_API_URL: $STAGING_API_URL
    VUE_APP_SYSTEM: $STAGING_SYSTEM

deploy frontend staging:
  extends: .deploy frontend base
  rules:
    - if: '$CI_COMMIT_BRANCH == "staging" && $USE_VPN != "true"'
  needs:
    - build frontend staging
  variables:
    DEPLOY_HOST: $STAGING_HOST
    DEPLOY_PORT: $STAGING_PORT
    DEPLOY_USER: $STAGING_USER
    DEPLOY_PATH: $STAGING_PATH

deploy frontend staging with vpn:
  extends:
    - deploy frontend staging
    - .use_vpn_service
  rules:
    - if: '$CI_COMMIT_BRANCH == "staging" && $USE_VPN == "true"'
  retry: 2 # Retries this job up to 2 times upon failure. VPN's can be flaky, so this is useful.
  # Since we can only have one VPN connection active at a time, we need to execute the deployment jobs sequentially.
  needs:
    - job: build frontend          # 1. Download artifacts from the build job
    - job: deploy backend with vpn # 2. Wait for the backend deploy to finish successfully
  before_script:
    - *ssh_configuration
    - *deploy_frontend_base_before_script
    - *vpn_setup
